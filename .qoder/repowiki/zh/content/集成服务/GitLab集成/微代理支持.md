# 微代理支持

<cite>
**本文档引用的文件**
- [gitlab.md](file://microagents/gitlab.md)
- [gitlab_service.py](file://openhands/integrations/gitlab/service/prs.py)
- [base.py](file://openhands/integrations/gitlab/service/base.py)
- [branches.py](file://openhands/integrations/gitlab/service/branches.py)
- [mcp.py](file://openhands/server/routes/mcp.py)
- [gitlab_service.py](file://enterprise/integrations/gitlab/gitlab_service.py)
- [http_session.py](file://openhands/utils/http_session.py)
- [token_manager.py](file://enterprise/server/auth/token_manager.py)
</cite>

## 目录
1. [简介](#简介)
2. [GitLab微代理配置](#gitlab微代理配置)
3. [API认证与令牌管理](#api认证与令牌管理)
4. [分支管理策略](#分支管理策略)
5. [合并请求创建流程](#合并请求创建流程)
6. [推送最佳实践](#推送最佳实践)
7. [实际使用案例](#实际使用案例)
8. [错误恢复与令牌刷新机制](#错误恢复与令牌刷新机制)
9. [结论](#结论)

## 简介

本文档详细描述了OpenHands平台中GitLab微代理的交互模式和使用方法。基于microagents/gitlab.md中的指令集，本文档涵盖了AI代理与GitLab的完整交互流程，包括环境变量配置、API调用、分支管理、合并请求创建和推送最佳实践。文档还提供了实际使用案例，展示从代码修改到合并请求提交的完整工作流，并详细说明了错误恢复和令牌刷新机制。

**微代理**是OpenHands平台中的核心组件，它们为AI代理提供特定领域的专业知识和操作能力。GitLab微代理专门处理与GitLab平台的交互，使AI代理能够自动化代码审查、分支管理和合并请求等开发任务。

**Section sources**
- [gitlab.md](file://microagents/gitlab.md)

## GitLab微代理配置

GitLab微代理的配置主要通过microagents/gitlab.md文件中的元数据定义。该文件声明了微代理的基本属性和触发条件，确保AI代理在适当的情况下激活GitLab相关功能。

```mermaid
erDiagram
MICROAGENT {
string name
string type
string version
string agent
list triggers
}
MICROAGENT ||--o{ TRIGGER : has
MICROAGENT ||--o{ INPUT : requires
```

微代理配置包含以下关键属性：
- **name**: 微代理的唯一标识符，此处为"gitlab"
- **type**: 微代理类型，此处为"knowledge"，表示这是一个知识型微代理
- **version**: 版本号，用于跟踪微代理的更新
- **agent**: 关联的AI代理类型，此处为"CodeActAgent"
- **triggers**: 触发微代理激活的关键字列表，包括"gitlab"和"git"

当用户在对话中提及这些关键字时，AI代理会自动激活GitLab微代理，启用与GitLab平台的交互能力。

**Section sources**
- [gitlab.md](file://microagents/gitlab.md)

## API认证与令牌管理

GitLab微代理通过环境变量`GITLAB_TOKEN`进行API认证，这是与GitLab平台交互的安全凭证。该令牌允许AI代理执行各种GitLab API操作，如创建合并请求、获取分支信息和管理代码库。

```mermaid
sequenceDiagram
participant AI代理 as AI代理
participant GitLab服务 as GitLab服务
participant GitLabAPI as GitLab API
AI代理->>GitLab服务 : 初始化服务实例
GitLab服务->>GitLab服务 : 从环境变量获取GITLAB_TOKEN
GitLab服务->>GitLabAPI : 发送带Bearer令牌的请求
GitLabAPI-->>GitLab服务 : 返回API响应
GitLab服务-->>AI代理 : 处理并返回结果
```

令牌管理机制确保了API调用的安全性和可靠性：
1. **环境变量注入**: `GITLAB_TOKEN`通过环境变量注入到AI代理的运行环境中
2. **HTTP头构造**: 令牌被用于构造Authorization头，格式为"Bearer {token}"
3. **请求验证**: GitLab API验证令牌的有效性，授权相应的操作权限

令牌的权限范围通常包括API访问、用户信息读取和仓库读写权限，确保AI代理能够完成必要的开发任务。

**Diagram sources**
- [gitlab.md](file://microagents/gitlab.md)
- [gitlab_service.py](file://openhands/integrations/gitlab/service/base.py)

**Section sources**
- [gitlab.md](file://microagents/gitlab.md)
- [gitlab_service.py](file://openhands/integrations/gitlab/service/base.py)

## 分支管理策略

GitLab微代理遵循严格的分支管理策略，确保代码开发的有序性和安全性。这些策略在microagents/gitlab.md文件中有明确说明，指导AI代理在不同场景下的分支操作行为。

```mermaid
flowchart TD
Start([开始]) --> CheckBranch["检查当前分支"]
CheckBranch --> OnMain{"是否在main/master分支?"}
OnMain --> |是| CreateNewBranch["创建新分支"]
OnMain --> |否| CheckBranchName{"分支名是否合适?"}
CheckBranchName --> |否| RenameBranch["重命名分支"]
CheckBranchName --> |是| ContinueDevelopment["继续开发"]
CreateNewBranch --> SwitchBranch["切换到新分支"]
SwitchBranch --> ContinueDevelopment
ContinueDevelopment --> End([结束])
```

核心分支管理规则包括：
- **禁止直接推送**: 严禁直接向`main`或`master`分支推送代码，确保主分支的稳定性
- **分支命名规范**: 创建具有描述性的新分支名称，避免使用默认的`openhands-workspace`前缀
- **分支保护**: 尊重GitLab的分支保护规则，不绕过代码审查和CI/CD流程
- **状态检查**: 在创建合并请求前，确保分支处于最新状态并与目标分支同步

这些策略确保了代码开发流程的规范性，防止意外的代码覆盖和冲突。

**Diagram sources**
- [gitlab.md](file://microagents/gitlab.md)
- [branches.py](file://openhands/integrations/gitlab/service/branches.py)

**Section sources**
- [gitlab.md](file://microagents/gitlab.md)
- [branches.py](file://openhands/integrations/gitlab/service/branches.py)

## 合并请求创建流程

`create_mr`工具是GitLab微代理的核心功能之一，负责创建和管理合并请求（Merge Request）。该工具的实现基于GitLab API，通过`GitLabPRsMixin`类中的`create_mr`方法提供服务。

```mermaid
sequenceDiagram
participant 用户 as 用户
participant AI代理 as AI代理
participant GitLab服务 as GitLab服务
participant GitLabAPI as GitLab API
用户->>AI代理 : 请求创建合并请求
AI代理->>GitLab服务 : 调用create_mr方法
GitLab服务->>GitLab服务 : 构造API请求参数
GitLab服务->>GitLabAPI : 发送POST请求创建MR
GitLabAPI-->>GitLab服务 : 返回MR创建结果
GitLab服务-->>AI代理 : 返回MR URL
AI代理->>用户 : 发送MR链接和简短消息
```

`create_mr`方法的实现细节：
- **参数验证**: 接收项目ID、源分支、目标分支、标题、描述和标签等参数
- **URL编码**: 对项目ID进行URL编码处理，确保API调用的正确性
- **默认描述**: 如果未提供描述，则生成默认描述"从{源分支}向{目标分支}合并更改"
- **标签处理**: 将标签列表转换为逗号分隔的字符串
- **API调用**: 使用POST方法向GitLab API发送创建合并请求的请求
- **结果返回**: 成功时返回合并请求的Web URL，失败时返回错误信息

该流程确保了合并请求创建的自动化和可靠性，同时提供了清晰的反馈给用户。

**Diagram sources**
- [prs.py](file://openhands/integrations/gitlab/service/prs.py)
- [mcp.py](file://openhands/server/routes/mcp.py)

**Section sources**
- [prs.py](file://openhands/integrations/gitlab/service/prs.py)
- [mcp.py](file://openhands/server/routes/mcp.py)

## 推送最佳实践

GitLab微代理遵循一系列推送最佳实践，确保代码提交的高效性和安全性。这些实践在microagents/gitlab.md文件中有详细说明，指导AI代理在不同场景下的推送行为。

```mermaid
flowchart LR
A[开始] --> B[检查当前状态]
B --> C{需要创建新分支?}
C --> |是| D[创建描述性分支名]
C --> |否| E[使用现有分支]
D --> F[添加所有更改]
E --> F
F --> G[提交更改]
G --> H[推送到远程]
H --> I[创建或更新MR]
I --> J[发送MR链接]
J --> K[结束]
```

关键推送实践包括：
- **最小化步骤**: 尽可能在最少的步骤内完成推送，提高效率
- **分支创建**: 如果当前分支名称不合适，创建具有描述性的新分支
- **原子提交**: 确保每次提交都是一个完整的逻辑单元
- **推送跟踪**: 使用`-u`参数设置上游分支，便于后续推送
- **MR更新**: 更新现有合并请求的标题和描述，但不更改分支名称

这些实践确保了代码推送的高效性和可追溯性，同时保持了开发流程的连续性。

**Diagram sources**
- [gitlab.md](file://microagents/gitlab.md)
- [branches.py](file://openhands/integrations/gitlab/service/branches.py)

**Section sources**
- [gitlab.md](file://microagents/gitlab.md)
- [branches.py](file://openhands/integrations/gitlab/service/branches.py)

## 实际使用案例

以下是一个完整的实际使用案例，展示从代码修改到合并请求提交的完整工作流。该案例基于microagents/gitlab.md中的指导原则和实际代码实现。

```mermaid
sequenceDiagram
participant 开发者 as 开发者
participant AI代理 as AI代理
participant GitLab服务 as GitLab服务
participant GitLabAPI as GitLab API
开发者->>AI代理 : "请修复登录页面的样式问题"
AI代理->>AI代理 : 分析问题并修改代码
AI代理->>GitLab服务 : 检查当前分支状态
GitLab服务-->>AI代理 : 返回当前分支信息
AI代理->>AI代理 : 创建新分支"fix-login-styles"
AI代理->>AI代理 : 添加并提交更改
AI代理->>GitLab服务 : 推送到远程分支
GitLab服务->>GitLabAPI : 执行git push命令
GitLabAPI-->>GitLab服务 : 推送成功
GitLab服务-->>AI代理 : 推送完成
AI代理->>GitLab服务 : 调用create_mr创建合并请求
GitLab服务->>GitLabAPI : 发送创建MR的API请求
GitLabAPI-->>GitLab服务 : 返回MR URL
GitLab服务-->>AI代理 : MR创建成功
AI代理->>开发者 : "已创建合并请求 : [MR链接]"
```

工作流详细步骤：
1. **问题分析**: AI代理接收开发者请求，分析登录页面的样式问题
2. **代码修改**: 在本地工作区修改CSS文件，修复样式问题
3. **分支检查**: 检查当前分支状态，发现需要创建新分支
4. **分支创建**: 创建名为"fix-login-styles"的新分支
5. **代码提交**: 添加所有更改并提交，提交信息为"修复登录页面样式问题"
6. **远程推送**: 将更改推送到GitLab远程仓库
7. **合并请求**: 调用`create_mr`工具创建合并请求，标题为"修复登录页面样式"
8. **结果通知**: 向开发者发送合并请求链接和简短说明

这个案例展示了GitLab微代理如何自动化完成从问题修复到代码提交的完整开发流程。

**Diagram sources**
- [gitlab.md](file://microagents/gitlab.md)
- [prs.py](file://openhands/integrations/gitlab/service/prs.py)
- [mcp.py](file://openhands/server/routes/mcp.py)

**Section sources**
- [gitlab.md](file://microagents/gitlab.md)
- [prs.py](file://openhands/integrations/gitlab/service/prs.py)
- [mcp.py](file://openhands/server/routes/mcp.py)

## 错误恢复与令牌刷新机制

GitLab微代理实现了完善的错误恢复和令牌刷新机制，确保在认证问题发生时能够自动恢复，保持服务的连续性。

```mermaid
sequenceDiagram
participant AI代理 as AI代理
participant GitLab服务 as GitLab服务
participant 令牌管理器 as 令牌管理器
participant GitLabAPI as GitLab API
AI代理->>GitLab服务 : 发送API请求
GitLab服务->>GitLabAPI : 带令牌的请求
GitLabAPI-->>GitLab服务 : 401未授权
GitLab服务->>GitLab服务 : 检测到令牌过期
GitLab服务->>令牌管理器 : 请求最新令牌
令牌管理器->>令牌管理器 : 刷新令牌
令牌管理器-->>GitLab服务 : 返回新令牌
GitLab服务->>GitLabAPI : 用新令牌重试请求
GitLabAPI-->>GitLab服务 : 请求成功
GitLab服务-->>AI代理 : 返回结果
```

错误恢复机制的关键组件：
- **令牌过期检测**: 在`_has_token_expired`方法中检测HTTP状态码，识别401未授权错误
- **自动刷新**: 当检测到令牌过期时，自动调用`get_latest_token`获取新令牌
- **请求重试**: 使用新令牌重新发送失败的API请求
- **错误处理**: 捕获并处理各种HTTP错误，提供有意义的错误信息

令牌刷新的具体实现：
1. **多源令牌获取**: 支持从`external_auth_token`、`external_auth_id`或`user_id`获取令牌
2. **令牌缓存**: 缓存获取的令牌，避免频繁的API调用
3. **刷新策略**: 在请求失败后自动刷新令牌，确保后续请求的成功
4. **日志记录**: 详细记录令牌获取和刷新过程，便于调试和监控

此外，当遇到推送认证问题时，微代理会建议更新远程URL以包含当前令牌：
```bash
git remote set-url origin https://oauth2:${GITLAB_TOKEN}@gitlab.com/username/repo.git
```

这种机制确保了即使令牌过期，系统也能自动恢复，无需人工干预。

**Diagram sources**
- [base.py](file://openhands/integrations/gitlab/service/base.py)
- [gitlab_service.py](file://enterprise/integrations/gitlab/gitlab_service.py)
- [token_manager.py](file://enterprise/server/auth/token_manager.py)

**Section sources**
- [base.py](file://openhands/integrations/gitlab/service/base.py)
- [gitlab_service.py](file://enterprise/integrations/gitlab/gitlab_service.py)
- [token_manager.py](file://enterprise/server/auth/token_manager.py)

## 结论

本文档全面介绍了OpenHands平台中GitLab微代理的支持功能，涵盖了从配置、认证到实际操作的各个方面。通过深入分析microagents/gitlab.md文件和相关代码实现，我们详细描述了AI代理与GitLab的交互模式。

GitLab微代理通过环境变量`GITLAB_TOKEN`实现安全的API认证，利用`create_mr`工具自动化合并请求的创建流程。严格的分支管理策略和推送最佳实践确保了代码开发的规范性和安全性。完善的错误恢复和令牌刷新机制保证了服务的可靠性和连续性。

实际使用案例展示了从代码修改到合并请求提交的完整工作流，体现了微代理在自动化开发任务中的强大能力。这些功能共同构成了一个高效、安全的GitLab集成解决方案，为开发者提供了无缝的AI辅助开发体验。

未来的工作可以进一步优化令牌管理策略，增强错误处理的智能化程度，并扩展对更多GitLab功能的支持，如代码审查评论、CI/CD状态监控和项目管理集成。