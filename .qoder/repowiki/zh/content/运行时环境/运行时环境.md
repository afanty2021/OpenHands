# 运行时环境

<cite>
**本文档中引用的文件**
- [openhands/runtime/__init__.py](file://openhands/runtime/__init__.py)
- [openhands/runtime/base.py](file://openhands/runtime/base.py)
- [openhands/runtime/impl/docker/docker_runtime.py](file://openhands/runtime/impl/docker/docker_runtime.py)
- [openhands/runtime/impl/local/local_runtime.py](file://openhands/runtime/impl/local/local_runtime.py)
- [openhands/runtime/impl/remote/remote_runtime.py](file://openhands/runtime/impl/remote/remote_runtime.py)
- [openhands/runtime/utils/runtime_build.py](file://openhands/runtime/utils/runtime_build.py)
- [openhands/runtime/action_execution_server.py](file://openhands/runtime/action_execution_server.py)
- [containers/app/Dockerfile](file://containers/app/Dockerfile)
- [containers/dev/Dockerfile](file://containers/dev/Dockerfile)
- [containers/runtime/README.md](file://containers/runtime/README.md)
- [openhands/runtime/plugins/__init__.py](file://openhands/runtime/plugins/__init__.py)
- [openhands/runtime/utils/command.py](file://openhands/runtime/utils/command.py)
</cite>

## 目录
1. [简介](#简介)
2. [运行时架构概览](#运行时架构概览)
3. [核心运行时类型](#核心运行时类型)
4. [安全隔离机制](#安全隔离机制)
5. [资源限制与性能监控](#资源限制与性能监控)
6. [运行时生命周期管理](#运行时生命周期管理)
7. [自定义运行时镜像](#自定义运行时镜像)
8. [运行时扩展机制](#运行时扩展机制)
9. [运行时选择指南](#运行时选择指南)
10. [故障排除](#故障排除)

## 简介

OpenHands的运行时环境是一个高度可扩展的沙箱系统，为AI代理提供了安全、隔离且功能丰富的执行环境。该系统支持多种运行时类型，从本地开发到生产级容器化部署，满足不同场景的需求。

运行时环境的核心设计理念是：
- **安全性**：通过多层隔离机制确保系统安全
- **可扩展性**：支持插件和第三方运行时扩展
- **一致性**：为所有运行时提供统一的接口
- **性能**：优化的资源管理和监控机制

## 运行时架构概览

OpenHands运行时系统采用分层架构设计，提供了灵活的抽象层次和强大的扩展能力。

```mermaid
graph TB
subgraph "应用层"
A[OpenHands核心] --> B[运行时管理器]
end
subgraph "运行时抽象层"
B --> C[Runtime基类]
C --> D[ActionExecutionClient]
end
subgraph "具体运行时实现"
D --> E[DockerRuntime]
D --> F[LocalRuntime]
D --> G[RemoteRuntime]
D --> H[KubernetesRuntime]
D --> I[CLIRuntime]
end
subgraph "第三方运行时"
J[Third-party Runtimes]
K[E2BRuntime]
L[DaytonaRuntime]
M[其他运行时]
end
subgraph "执行环境"
N[Docker容器]
O[本地进程]
P[远程服务器]
Q[Kubernetes Pod]
end
E --> N
F --> O
G --> P
H --> Q
I --> O
J --> K
J --> L
J --> M
```

**图表来源**
- [openhands/runtime/__init__.py](file://openhands/runtime/__init__.py#L14-L21)
- [openhands/runtime/base.py](file://openhands/runtime/base.py#L91-L115)

**章节来源**
- [openhands/runtime/__init__.py](file://openhands/runtime/__init__.py#L1-L120)
- [openhands/runtime/base.py](file://openhands/runtime/base.py#L1-L800)

## 核心运行时类型

### Docker运行时 (DockerRuntime)

Docker运行时是最常用的生产环境运行时，提供完整的容器化隔离。

```mermaid
classDiagram
class DockerRuntime {
+DockerClient docker_client
+Container container
+str container_name
+int _host_port
+int _vscode_port
+list _app_ports
+LogStreamer log_streamer
+connect() void
+run_action(action) Observation
+close() void
+wait_until_alive() void
}
class DockerRuntimeBuilder {
+DockerClient docker_client
+build_runtime_image() str
+image_exists(image_name) bool
}
class PortLock {
+acquire(port) bool
+release(port) void
}
DockerRuntime --> DockerRuntimeBuilder : "使用"
DockerRuntime --> PortLock : "管理端口"
```

**图表来源**
- [openhands/runtime/impl/docker/docker_runtime.py](file://openhands/runtime/impl/docker/docker_runtime.py#L75-L200)

**主要特性**：
- 完整的容器化隔离
- 自动端口映射和管理
- 日志流式传输
- 支持热重启和状态恢复

### 本地运行时 (LocalRuntime)

本地运行时适用于开发和测试场景，直接在主机上运行而无需容器化。

```mermaid
sequenceDiagram
participant App as 应用程序
participant LR as LocalRuntime
participant Server as ActionExecutionServer
participant Host as 主机系统
App->>LR : 初始化运行时
LR->>Server : 启动本地服务器
Server->>Host : 创建工作目录
Host-->>Server : 确认创建
Server-->>LR : 服务器就绪
LR-->>App : 连接成功
App->>LR : 执行命令
LR->>Server : 发送HTTP请求
Server->>Host : 执行命令
Host-->>Server : 返回结果
Server-->>LR : 观察结果
LR-->>App : 返回观察
```

**图表来源**
- [openhands/runtime/impl/local/local_runtime.py](file://openhands/runtime/impl/local/local_runtime.py#L124-L200)

**主要特性**：
- 高性能，无容器开销
- 简化的调试体验
- 适合开发和CI/CD环境

### 远程运行时 (RemoteRuntime)

远程运行时允许在专用基础设施上执行，支持大规模部署。

```mermaid
flowchart TD
A[RemoteRuntime初始化] --> B{检查现有运行时}
B --> |存在| C[连接到现有实例]
B --> |不存在| D[构建新运行时镜像]
D --> E[启动远程容器]
E --> F[等待服务就绪]
F --> G[建立连接]
C --> G
G --> H[运行时就绪]
H --> I[执行动作]
I --> J[返回观察]
J --> K{需要清理?}
K --> |是| L[停止运行时]
K --> |否| I
L --> M[清理完成]
```

**图表来源**
- [openhands/runtime/impl/remote/remote_runtime.py](file://openhands/runtime/impl/remote/remote_runtime.py#L135-L200)

**主要特性**：
- 支持Sysbox和gVisor运行时类
- 可配置的资源因子
- 自动扩缩容支持

**章节来源**
- [openhands/runtime/impl/docker/docker_runtime.py](file://openhands/runtime/impl/docker/docker_runtime.py#L1-L200)
- [openhands/runtime/impl/local/local_runtime.py](file://openhands/runtime/impl/local/local_runtime.py#L1-L200)
- [openhands/runtime/impl/remote/remote_runtime.py](file://openhands/runtime/impl/remote/remote_runtime.py#L1-L200)

## 安全隔离机制

OpenHands运行时系统实现了多层次的安全隔离机制，确保系统安全和数据保护。

### 容器级隔离

Docker运行时使用以下安全特性：

| 安全机制 | 实现方式 | 配置参数 |
|---------|---------|---------|
| 用户命名空间 | `run_as_user` 和 `run_as_group` | `RUNTIME_UID`, `RUNTIME_USERNAME` |
| 文件系统隔离 | 只读根文件系统 | `readonly_root_fs` |
| 资源限制 | cgroups | `cpu_period`, `cpu_quota`, `mem_limit` |
| 网络隔离 | 独立网络命名空间 | `network_mode` |
| 设备访问控制 | 设备白名单 | `devices` |

### 进程级隔离

每个运行时都运行在独立的进程中，具有：
- 唯一的用户ID和组ID
- 限制的文件系统权限
- 独立的环境变量空间

### 网络安全

```mermaid
graph LR
subgraph "外部网络"
A[客户端]
B[API网关]
end
subgraph "OpenHands服务器"
C[后端服务]
D[运行时管理器]
end
subgraph "运行时环境"
E[Docker容器]
F[本地进程]
G[远程实例]
end
A --> B
B --> C
C --> D
D --> E
D --> F
D --> G
E -.->|受限网络| H[内部服务]
F -.->|受限网络| H
G -.->|受限网络| H
```

**图表来源**
- [openhands/runtime/impl/docker/docker_runtime.py](file://openhands/runtime/impl/docker/docker_runtime.py#L131-L140)

**章节来源**
- [openhands/runtime/impl/docker/docker_runtime.py](file://openhands/runtime/impl/docker/docker_runtime.py#L131-L140)

## 资源限制与性能监控

### 资源限制配置

OpenHands支持细粒度的资源限制配置：

| 资源类型 | 配置参数 | 默认值 | 说明 |
|---------|---------|--------|------|
| CPU周期 | `cpu_period` | 100000 | 每个周期100ms |
| CPU配额 | `cpu_quota` | 100000 | 可使用100ms |
| 内存限制 | `mem_limit` | 4G | 最大内存使用 |
| 交换内存 | `memswap_limit` | 0 | 禁用交换 |
| 文件描述符 | `ulimit` | 65536 | 最大文件句柄数 |

### 性能监控指标

```mermaid
graph TB
subgraph "系统指标"
A[CPU使用率]
B[内存使用量]
C[磁盘I/O]
D[网络带宽]
end
subgraph "应用指标"
E[响应时间]
F[吞吐量]
G[错误率]
H[并发请求数]
end
subgraph "运行时指标"
I[容器健康状态]
J[端口可用性]
K[日志频率]
L[资源使用趋势]
end
A --> M[监控系统]
B --> M
C --> M
D --> M
E --> M
F --> M
G --> M
H --> M
I --> M
J --> M
K --> M
L --> M
```

**图表来源**
- [openhands/runtime/utils/system_stats.py](file://openhands/runtime/utils/system_stats.py)

### 资源监控实现

运行时系统集成了实时监控机制：

```mermaid
sequenceDiagram
participant RT as 运行时
participant Monitor as 监控器
participant Alert as 告警系统
participant Admin as 管理员
RT->>Monitor : 报告资源使用
Monitor->>Monitor : 分析阈值
alt 超过阈值
Monitor->>Alert : 触发告警
Alert->>Admin : 发送通知
Admin->>RT : 调整配置
else 正常范围
Monitor->>Monitor : 记录统计数据
end
```

**章节来源**
- [tests/runtime/test_runtime_resource.py](file://tests/runtime/test_runtime_resource.py#L41-L115)

## 运行时生命周期管理

### 启动流程

运行时的启动遵循标准化的生命周期管理：

```mermaid
flowchart TD
A[初始化运行时] --> B[验证配置]
B --> C{配置有效?}
C --> |否| D[抛出异常]
C --> |是| E[检查现有实例]
E --> F{实例存在?}
F --> |是| G[附加到现有实例]
F --> |否| H[创建新实例]
H --> I[构建运行时镜像]
I --> J[启动容器/进程]
J --> K[等待服务就绪]
K --> L[建立连接]
L --> M[初始化环境]
M --> N[运行时就绪]
G --> N
N --> O[开始接收动作]
```

**图表来源**
- [openhands/runtime/base.py](file://openhands/runtime/base.py#L370-L390)

### 执行流程

```mermaid
sequenceDiagram
participant Agent as AI代理
participant Runtime as 运行时
participant Executor as 动作执行器
participant Env as 执行环境
Agent->>Runtime : 发送动作
Runtime->>Runtime : 验证动作
Runtime->>Executor : 解析动作类型
Executor->>Env : 执行具体操作
Env-->>Executor : 返回结果
Executor-->>Runtime : 构建观察
Runtime-->>Agent : 返回观察结果
Note over Runtime,Env : 支持超时和错误处理
```

**图表来源**
- [openhands/runtime/base.py](file://openhands/runtime/base.py#L370-L410)

### 清理流程

运行时的清理过程确保资源的正确释放：

```mermaid
flowchart TD
A[开始清理] --> B{保持运行时活跃?}
B --> |是| C[暂停运行时]
B --> |否| D[停止运行时]
C --> E[发送暂停请求]
E --> F[等待确认]
F --> G[清理临时文件]
D --> H[发送停止请求]
H --> I[等待确认]
I --> G
G --> J[关闭连接]
J --> K[释放资源]
K --> L[清理完成]
```

**图表来源**
- [openhands/runtime/impl/remote/remote_runtime.py](file://openhands/runtime/impl/remote/remote_runtime.py#L485-L516)

**章节来源**
- [openhands/runtime/base.py](file://openhands/runtime/base.py#L370-L410)
- [openhands/runtime/impl/remote/remote_runtime.py](file://openhands/runtime/impl/remote/remote_runtime.py#L485-L516)

## 自定义运行时镜像

### 镜像构建流程

OpenHands提供了自动化的运行时镜像构建系统：

```mermaid
graph TB
subgraph "源码准备"
A[基础镜像] --> B[构建上下文]
C[运行时模板] --> B
D[依赖文件] --> B
end
subgraph "构建策略"
B --> E{构建类型}
E --> |SCRATCH| F[从头构建]
E --> |VERSIONED| G[基于版本缓存]
E --> |LOCK| H[基于锁定文件]
end
subgraph "优化选项"
F --> I[完整安装]
G --> J[增量更新]
H --> K[精确匹配]
end
subgraph "输出"
I --> L[最终镜像]
J --> L
K --> L
end
```

**图表来源**
- [openhands/runtime/utils/runtime_build.py](file://openhands/runtime/utils/runtime_build.py#L31-L62)

### 自定义镜像配置

创建自定义运行时镜像的步骤：

1. **选择基础镜像**：基于官方推荐的基础镜像
2. **配置构建参数**：设置额外依赖和环境变量
3. **启用浏览器支持**（可选）：安装Playwright和浏览器
4. **优化构建缓存**：利用分层缓存机制

### 镜像标签管理

```mermaid
flowchart LR
A[源码哈希] --> B[镜像标签]
C[依赖哈希] --> B
D[版本信息] --> B
E[基础镜像] --> B
B --> F[ghcr.io/openhands/runtime:<标签>]
F --> G[镜像仓库]
G --> H[版本化存储]
H --> I[快速检索]
```

**图表来源**
- [openhands/runtime/utils/runtime_build.py](file://openhands/runtime/utils/runtime_build.py#L65-L105)

**章节来源**
- [openhands/runtime/utils/runtime_build.py](file://openhands/runtime/utils/runtime_build.py#L1-L200)
- [containers/runtime/README.md](file://containers/runtime/README.md#L1-L13)

## 运行时扩展机制

### 插件系统

OpenHands运行时支持插件扩展，提供模块化功能增强：

```mermaid
classDiagram
class Plugin {
<<abstract>>
+str name
+load() void
+unload() void
+execute(args) Result
}
class VSCodePlugin {
+str name = "vscode"
+start_server() void
+stop_server() void
}
class JupyterPlugin {
+str name = "jupyter"
+start_kernel() void
+stop_kernel() void
}
class AgentSkillsPlugin {
+str name = "agent_skills"
+execute_skill(skill) Result
}
Plugin <|-- VSCodePlugin
Plugin <|-- JupyterPlugin
Plugin <|-- AgentSkillsPlugin
```

**图表来源**
- [openhands/runtime/plugins/__init__.py](file://openhands/runtime/plugins/__init__.py#L1-L26)

### 第三方运行时集成

系统支持第三方运行时的动态发现和加载：

```mermaid
sequenceDiagram
participant Init as 运行时初始化
participant Discovery as 第三方发现器
participant Loader as 模块加载器
participant Runtime as 第三方运行时
Init->>Discovery : 扫描第三方包
Discovery->>Discovery : 查找运行时模块
Discovery->>Loader : 尝试导入模块
Loader->>Loader : 查找运行时类
Loader->>Runtime : 实例化运行时
Runtime-->>Init : 注册到运行时列表
```

**图表来源**
- [openhands/runtime/__init__.py](file://openhands/runtime/__init__.py#L27-L80)

### 扩展点设计

| 扩展点类型 | 接口方法 | 用途 |
|-----------|---------|------|
| 运行时插件 | `Plugin.load()` | 加载额外功能 |
| 动作处理器 | `ActionExecutionClient.run_action()` | 自定义动作处理 |
| 环境配置 | `Runtime.setup_initial_env()` | 自定义环境设置 |
| 监控钩子 | `Runtime.set_runtime_status()` | 自定义状态报告 |

**章节来源**
- [openhands/runtime/plugins/__init__.py](file://openhands/runtime/plugins/__init__.py#L1-L26)
- [openhands/runtime/__init__.py](file://openhands/runtime/__init__.py#L27-L80)

## 运行时选择指南

### 场景分析矩阵

根据不同的使用场景，推荐相应的运行时类型：

| 使用场景 | 推荐运行时 | 理由 | 配置要点 |
|---------|-----------|------|---------|
| 开发测试 | LocalRuntime | 高性能，易调试 | 关闭安全限制 |
| 生产部署 | DockerRuntime | 完整隔离，可扩展 | 配置资源限制 |
| 大规模集群 | KubernetesRuntime | 弹性扩展，资源优化 | 配置调度策略 |
| 云原生环境 | RemoteRuntime | 专用基础设施 | 配置API密钥 |
| 特殊需求 | 自定义运行时 | 定制化功能 | 开发插件扩展 |

### 性能对比

```mermaid
graph LR
subgraph "性能指标"
A[启动时间]
B[内存占用]
C[CPU效率]
D[网络延迟]
end
subgraph "运行时类型"
E[LocalRuntime<br/>最快启动<br/>最低内存<br/>最高CPU<br/>零网络延迟]
F[DockerRuntime<br/>中等启动<br/>中等内存<br/>中等CPU<br/>低网络延迟]
G[RemoteRuntime<br/>最慢启动<br/>最高内存<br/>最低CPU<br/>高网络延迟]
end
A --> E
A --> F
A --> G
B --> E
B --> F
B --> G
C --> E
C --> F
C --> G
D --> E
D --> F
D --> G
```

### 安全级别评估

| 安全级别 | 运行时类型 | 隔离强度 | 适用场景 |
|---------|-----------|---------|---------|
| 高 | DockerRuntime | 完整容器隔离 | 生产环境 |
| 中 | LocalRuntime | 进程级隔离 | 开发测试 |
| 低 | RemoteRuntime | 网络隔离 | 受控环境 |
| 最低 | KubernetesRuntime | 集群级隔离 | 大规模部署 |

## 故障排除

### 常见问题诊断

#### Docker运行时问题

**问题**：容器启动失败
**排查步骤**：
1. 检查Docker守护进程状态
2. 验证基础镜像可用性
3. 检查端口冲突
4. 查看容器日志

**解决方案**：
```bash
# 检查Docker状态
docker info

# 查看容器日志
docker logs <container_id>

# 清理未使用的资源
docker system prune -f
```

#### 远程运行时问题

**问题**：连接超时
**排查步骤**：
1. 检查网络连通性
2. 验证API密钥
3. 确认远程服务状态
4. 检查防火墙设置

**解决方案**：
```bash
# 测试连接
curl -H "X-API-Key: <api_key>" \
     https://<remote_runtime_url>/health

# 检查服务状态
curl -H "X-API-Key: <api_key>" \
     https://<remote_runtime_url>/status
```

### 性能调优建议

#### 资源优化

1. **内存管理**：
   - 设置合理的`mem_limit`
   - 配置`memswap_limit`为0
   - 监控内存使用趋势

2. **CPU优化**：
   - 调整`cpu_period`和`cpu_quota`
   - 使用CPU亲和性绑定
   - 避免过度分配CPU资源

3. **存储优化**：
   - 使用SSD存储
   - 配置适当的卷挂载
   - 定期清理临时文件

#### 监控配置

```mermaid
graph TB
A[监控配置] --> B[指标收集]
A --> C[告警规则]
A --> D[日志管理]
B --> E[系统指标]
B --> F[应用指标]
B --> G[业务指标]
C --> H[阈值告警]
C --> I[趋势告警]
C --> J[异常检测]
D --> K[结构化日志]
D --> L[日志轮转]
D --> M[集中存储]
```

### 故障恢复策略

1. **自动恢复**：配置重试机制和健康检查
2. **手动干预**：提供紧急停止和重启接口
3. **数据备份**：定期备份重要数据和配置
4. **灾难恢复**：制定详细的恢复计划

**章节来源**
- [openhands/runtime/impl/docker/docker_runtime.py](file://openhands/runtime/impl/docker/docker_runtime.py#L57-L73)
- [openhands/runtime/impl/remote/remote_runtime.py](file://openhands/runtime/impl/remote/remote_runtime.py#L135-L200)

## 结论

OpenHands的运行时环境系统提供了强大而灵活的执行环境，支持从开发到生产的各种场景需求。通过模块化的架构设计、完善的安全机制和丰富的扩展能力，该系统能够满足现代AI应用对可靠性和可扩展性的要求。

关键优势包括：
- **安全性**：多层隔离机制确保系统安全
- **可扩展性**：插件和第三方运行时支持
- **性能**：优化的资源管理和监控
- **易用性**：统一的接口和自动化配置

随着AI技术的不断发展，OpenHands运行时环境将继续演进，为更复杂的应用场景提供支持。